// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {
    FHE,
    euint256,
    eaddress,
    externalEuint256,
    externalEaddress
} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

/// @title ConfidentialCourt
/// @notice Manages confidential court trials with fully homomorphic encryption support
contract ConfidentialCourt is ZamaEthereumConfig {
    struct Trial {
        address judge;
        address partyA;
        address partyB;
        bool isActive;
        uint256 createdAt;
    }

    struct Message {
        address sender;
        euint256 content;
        eaddress authorAddress;
        uint256 timestamp;
    }

    error ZeroAddress();
    error DuplicateParty();
    error TrialDoesNotExist();
    error TrialAlreadyClosed();
    error NotJudge();
    error SenderNotParticipant();
    error MessageOutOfBounds();

    uint256 private _nextTrialId;
    mapping(uint256 => Trial) private _trials;
    mapping(uint256 => Message[]) private _messages;
    mapping(address => uint256[]) private _trialsByParticipant;

    event TrialCreated(uint256 indexed trialId, address indexed judge, address indexed partyA, address partyB);
    event TrialClosed(uint256 indexed trialId);
    event MessagePosted(uint256 indexed trialId, address indexed sender, uint256 indexed messageIndex);

    /// @notice Creates a new trial assigning the caller as judge
    /// @param partyA Address of the first participant
    /// @param partyB Address of the second participant
    /// @return trialId Identifier of the created trial
    function createTrial(address partyA, address partyB) external returns (uint256 trialId) {
        if (partyA == address(0) || partyB == address(0)) {
            revert ZeroAddress();
        }
        if (partyA == partyB) {
            revert DuplicateParty();
        }

        trialId = ++_nextTrialId;

        _trials[trialId] = Trial({
            judge: msg.sender,
            partyA: partyA,
            partyB: partyB,
            isActive: true,
            createdAt: block.timestamp
        });

        _trialsByParticipant[msg.sender].push(trialId);
        _trialsByParticipant[partyA].push(trialId);
        _trialsByParticipant[partyB].push(trialId);

        emit TrialCreated(trialId, msg.sender, partyA, partyB);
    }

    /// @notice Closes an active trial (only the judge can close it)
    /// @param trialId Identifier of the trial to close
    function closeTrial(uint256 trialId) external {
        Trial storage trial = _trials[trialId];
        if (trial.judge == address(0)) {
            revert TrialDoesNotExist();
        }
        if (trial.judge != msg.sender) {
            revert NotJudge();
        }
        if (!trial.isActive) {
            revert TrialAlreadyClosed();
        }

        trial.isActive = false;

        emit TrialClosed(trialId);
    }

    /// @notice Posts an encrypted message to a trial
    /// @param trialId Identifier of the trial
    /// @param encryptedMessage Encrypted message payload
    /// @param encryptedAuthorAddress Encrypted temporary author address
    /// @param inputProof Proof generated by the relayer SDK for the encrypted inputs
    function sendMessage(
        uint256 trialId,
        externalEuint256 encryptedMessage,
        externalEaddress encryptedAuthorAddress,
        bytes calldata inputProof
    ) external {
        Trial storage trial = _trials[trialId];
        if (trial.judge == address(0)) {
            revert TrialDoesNotExist();
        }
        if (!trial.isActive) {
            revert TrialAlreadyClosed();
        }

        address sender = msg.sender;
        if (sender != trial.judge && sender != trial.partyA && sender != trial.partyB) {
            revert SenderNotParticipant();
        }

        euint256 messageContent = FHE.fromExternal(encryptedMessage, inputProof);
        eaddress authorAddress = FHE.fromExternal(encryptedAuthorAddress, inputProof);

        FHE.allowThis(messageContent);
        FHE.allowThis(authorAddress);

        FHE.allow(messageContent, trial.judge);
        FHE.allow(messageContent, trial.partyA);
        FHE.allow(messageContent, trial.partyB);

        FHE.allow(authorAddress, trial.judge);
        FHE.allow(authorAddress, trial.partyA);
        FHE.allow(authorAddress, trial.partyB);

        Message memory newMessage = Message({
            sender: sender,
            content: messageContent,
            authorAddress: authorAddress,
            timestamp: block.timestamp
        });

        _messages[trialId].push(newMessage);

        emit MessagePosted(trialId, sender, _messages[trialId].length - 1);
    }

    /// @notice Gets information about a specific trial
    function getTrial(uint256 trialId)
        external
        view
        returns (address judge, address partyA, address partyB, bool isActive, uint256 createdAt, uint256 messageCount)
    {
        Trial storage trial = _trials[trialId];
        if (trial.judge == address(0)) {
            revert TrialDoesNotExist();
        }

        return (trial.judge, trial.partyA, trial.partyB, trial.isActive, trial.createdAt, _messages[trialId].length);
    }

    /// @notice Lists trial identifiers associated with an address
    function getTrialsForAddress(address account) external view returns (uint256[] memory) {
        return _trialsByParticipant[account];
    }

    /// @notice Returns the number of messages recorded for a trial
    function getMessageCount(uint256 trialId) external view returns (uint256) {
        if (_trials[trialId].judge == address(0)) {
            revert TrialDoesNotExist();
        }
        return _messages[trialId].length;
    }

    /// @notice Gets a specific message from a trial
    function getMessage(uint256 trialId, uint256 index)
        external
        view
        returns (address sender, euint256 encryptedContent, eaddress encryptedAuthorAddress, uint256 timestamp)
    {
        if (_trials[trialId].judge == address(0)) {
            revert TrialDoesNotExist();
        }

        if (index >= _messages[trialId].length) {
            revert MessageOutOfBounds();
        }

        Message storage messageData = _messages[trialId][index];
        return (messageData.sender, messageData.content, messageData.authorAddress, messageData.timestamp);
    }
}
